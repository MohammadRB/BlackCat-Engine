// [05/28/2021 MRB]

#pragma once

#include "CorePlatformImp/Concurrency/bcAtomic.h"
#include "Core/Memory/bcPtr.h"
#include "Core/Messaging/bcMessage.h"
#include "Core/File/bcJsonDocument.h"
#include "PlatformImp/Network/bcNetworkAddress.h"
#include "Game/System/Network/bcNetworkMessageVisitor.h"
#include "Game/System/Network/Server/bcNetworkClient.h"
#include "Game/bcExport.h"

namespace black_cat
{
	namespace game
	{
		template<class TCommand>
		struct bc_network_message_traits
		{
			static constexpr const bcCHAR* message_name()
			{
				return TCommand::message_name();
			}

			static constexpr bc_network_message_hash message_hash()
			{
				return TCommand::message_hash();
			}
		};

		class bc_network_system;
		class bci_network_message_visitor;
		class bci_network_message;
		using bc_network_message_ptr = core::bc_shared_ptr<bci_network_message>;

		template<class TMessage>
		bc_network_message_ptr bc_make_network_message(TMessage p_command)
		{
			return core::bc_make_shared<TMessage>(std::move(p_command));
		}

		struct bc_network_message_serialization_context
		{
			bci_network_message_serialization_visitor& m_visitor;
			core::bc_json_key_value& m_params;
		};

		struct bc_network_message_deserialization_context
		{
			bci_network_message_deserialization_visitor& m_visitor;
			const core::bc_json_key_value& m_params;
		};
		
		struct bc_network_message_client_context
		{
			bci_network_message_client_visitor& m_visitor;
			bci_network_message_visitor& m_injected_visitor;
		};

		struct bc_network_message_server_context
		{
			bci_network_message_server_visitor& m_visitor;
			bci_network_message_visitor& m_injected_visitor;
			const bc_network_client& m_client;
		};

		struct bc_network_message_client_acknowledge_context
		{
			bci_network_message_client_visitor& m_visitor;
			bci_network_message_visitor& m_injected_visitor;
			core::bc_string m_ack_data;
		};

		struct bc_network_message_server_acknowledge_context
		{
			bci_network_message_server_visitor& m_visitor;
			bci_network_message_visitor& m_injected_visitor;
			const bc_network_client& m_client;
			core::bc_string m_ack_data;
		};

		class bci_network_message_visitor
		{
		protected:
			virtual ~bci_network_message_visitor() = 0;
		};

		inline bci_network_message_visitor::~bci_network_message_visitor() = default;

		class BC_GAME_DLL bci_network_message : public core::bci_message
		{
		public:
			~bci_network_message() override = default;

			/**
			 * \brief Message id which is assigned by the sender of message.
			 * \n If message is sent by server this id is generated by the server.
			 * \n If message is sent by client this id is generated by the client.
			 * \return 
			 */
			bc_network_message_id get_id() const noexcept;
			
			/**
			 * \brief Indicate whether message must be acknowledged by the receiver or not
			 * \return
			 */
			virtual bool need_acknowledgment() const noexcept;

			/**
			 * \brief Indicate message is a game play message which would not be sent until client load game scene
			 * \return 
			 */
			virtual bool is_in_game_message() const noexcept;

			/**
			 * \brief Indicates messages is sent again because acknowledge message is not received by sender
			 * \return 
			 */
			bool get_is_retry() const noexcept;

			/**
			 * \brief Mark message is retry message because acknowledge message is not received by sender
			 */
			void set_is_retry() noexcept;
			
			/**
			 * \brief After message execution, if acknowledgment is required, this string will be included in acknowledge message
			 * \return 
			 */
			virtual core::bc_string get_acknowledgment_data() const noexcept;
			
			/**
			 * \brief Serialize command into json key/value pair which is provided as parameter
			 * \param p_context 
			 */
			void serialize(const bc_network_message_serialization_context& p_context);

			/**
			 * \brief Deserialize command from json key/value pair which is provided as parameter. 
			 * \param p_context
			 */
			void deserialize(const bc_network_message_deserialization_context& p_context);
			
			/**
			 * \brief Execute message logic on the remote part of connection
			 * \param p_context
			 */
			virtual void execute(const bc_network_message_client_context& p_context) noexcept;

			/**
			 * \brief Execute message logic on the remote part of connection
			 * \param p_context
			 */
			virtual void execute(const bc_network_message_server_context& p_context) noexcept;

			/**
			 * \brief Execute message logic when message delivery is acknowledged
			 * \param p_context 
			 */
			virtual void acknowledge(const bc_network_message_client_acknowledge_context& p_context) noexcept;

			/**
			 * \brief Execute message logic when message delivery is acknowledged
			 * \param p_context
			 */
			virtual void acknowledge(const bc_network_message_server_acknowledge_context& p_context) noexcept;
		
		protected:
			explicit bci_network_message(const bcCHAR* p_name) noexcept;

			bci_network_message(bci_network_message&&) noexcept = default;

			bci_network_message& operator=(bci_network_message&&) noexcept = default;

		private:
			virtual void serialize_message(const bc_network_message_serialization_context& p_context) = 0;

			virtual void deserialize_message(const bc_network_message_deserialization_context& p_context) = 0;

			static core_platform::bc_atomic<bc_network_message_id> s_id_counter;
			
			mutable bc_network_message_id m_id;
			bool m_is_retry;
		};

		inline bc_network_message_id bci_network_message::get_id() const noexcept
		{
			return m_id;
		}

		inline bool bci_network_message::need_acknowledgment() const noexcept
		{
			return false;
		}

		inline bool bci_network_message::is_in_game_message() const noexcept
		{
			return true;
		}

		inline bool bci_network_message::get_is_retry() const noexcept
		{
			return m_is_retry;
		}

		inline void bci_network_message::set_is_retry() noexcept
		{
			m_is_retry = true;
		}
	}
}