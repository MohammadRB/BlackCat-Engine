// [05/28/2021 MRB]

#pragma once

#include "CorePlatformImp/Utility/bcClock.h"
#include "CorePlatformImp/Concurrency/bcAtomic.h"
#include "Core/Memory/bcPtr.h"
#include "Core/Messaging/bcMessage.h"
#include "Core/File/bcJsonDocument.h"
#include "PlatformImp/Network/bcNetworkAddress.h"
#include "Game/bcConstant.h"
#include "Game/bcExport.h"

namespace black_cat
{
	namespace game
	{
		using bc_network_message_id = bcINT32; // it must be int because in json deserialization it is interpreted as int
		using bc_network_message_hash = core::bc_string_cmp_hash;

		template<class TCommand>
		struct bc_network_message_traits
		{
			static constexpr const bcCHAR* message_name()
			{
				return TCommand::message_name();
			}

			static constexpr bc_network_message_hash message_hash()
			{
				return TCommand::message_hash();
			}
		};

		class bc_network_system;
		class bc_network_client_manager;
		class bc_network_server_manager;
		class bci_network_message;
		using bc_network_message_ptr = core::bc_shared_ptr<bci_network_message>;

		template<class TMessage>
		bc_network_message_ptr bc_make_network_message(TMessage p_command)
		{
			return core::bc_make_shared<TMessage>(std::move(p_command));
		}
		
		struct bc_network_message_client_context
		{
			bc_network_client_manager& m_manager;
		};

		struct bc_network_message_server_context
		{
			const platform::bc_network_address& m_address;
			bc_network_server_manager& m_manager;
		};
		
		class BC_GAME_DLL bci_network_message : public core::bci_message
		{
		public:
			~bci_network_message() override = default;

			/**
			 * \brief Message id which is assigned by the sender of message.
			 * \n If message is sent by server this id is generated by the server.
			 * \n If message is sent by client this id is generated by the client.
			 * \return 
			 */
			bc_network_message_id get_id() const noexcept;
			
			/**
			 * \brief Serialize command into json key/value pair which is provided as parameter
			 * \param p_params 
			 */
			void serialize(core::bc_json_key_value& p_params) const;

			/**
			 * \brief Deserialize command from json key/value pair which is provided as parameter. 
			 * \param p_params
			 */
			void deserialize(const core::bc_json_key_value& p_params);

			/**
			 * \brief Indicate whether message must be acknowledged by the receiver or not
			 * \return 
			 */
			virtual bool need_acknowledgment() const noexcept;
			
			/**
			 * \brief Execute message logic on the remote part of connection
			 * \param p_context
			 */
			virtual void execute(const bc_network_message_client_context& p_context) noexcept;

			/**
			 * \brief Execute message logic on the remote part of connection
			 * \param p_context
			 */
			virtual void execute(const bc_network_message_server_context& p_context) noexcept;

			/**
			 * \brief Execute message logic when message delivery is acknowledged
			 * \param p_context 
			 */
			virtual void acknowledge(const bc_network_message_client_context& p_context) noexcept;

			/**
			 * \brief Execute message logic when message delivery is acknowledged
			 * \param p_context
			 */
			virtual void acknowledge(const bc_network_message_server_context& p_context) noexcept;
		
		protected:
			explicit bci_network_message(const bcCHAR* p_name) noexcept
				: bci_message(p_name),
				m_id(0)
			{
			}

			bci_network_message(bci_network_message&&) noexcept = default;

			bci_network_message& operator=(bci_network_message&&) noexcept = default;

		private:
			virtual void serialize_message(core::bc_json_key_value& p_params) const = 0;

			virtual void deserialize_message(const core::bc_json_key_value& p_params) = 0;

			static core_platform::bc_atomic<bc_network_message_id> s_id_counter;
			
			mutable bc_network_message_id m_id;
		};

		inline bc_network_message_id bci_network_message::get_id() const noexcept
		{
			return m_id;
		}

		inline bool bci_network_message::need_acknowledgment() const noexcept
		{
			return false;
		}
	}
}
